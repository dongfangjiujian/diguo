<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
<title>用连接池提高Servlet访问数据库的效率 - Powered by EmpireCMS</title>
<meta name="keywords" content="" />
<meta name="description" content="用连接池提高Servlet访问数据库的效率" />

	<link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="/skin/default/bootstrap/css/custom.css">

<script type="text/javascript" src="/skin/default/js/tabs.js"></script>

	<script src="https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script>
	<script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>

</head>
<body><div class="nav-just">
<nav class="nav navbar-default" role="navigation">
	<div class="container"> 
	<div class="navbar-header">
		<button type="button" class="navbar-toggle" data-toggle="collapse"
				data-target="#example-navbar-collapse">
			<span class="sr-only">切换导航</span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
		<a class="navbar-brand" href="/">香水百合</a>
	</div>
	<div class="collapse navbar-collapse" id="example-navbar-collapse">
		<ul class="nav navbar-nav">
			
			  <li id="tabnav_btn_1" onmouseover="tabit(this)"><a href="/news/">新闻中心</a></li><li id="tabnav_btn_2" onmouseover="tabit(this)"><a href="/xiangshuigushi/">香水故事</a></li><li id="tabnav_btn_3" onmouseover="tabit(this)"><a href="/xiangshuiyongfa/">香水用法</a></li><li id="tabnav_btn_4" onmouseover="tabit(this)"><a href="/xiangshuipinpai/">香水品牌</a></li><li id="tabnav_btn_5" onmouseover="tabit(this)"><a href="/xiangshuifenlei/">香水分类</a></li><li id="tabnav_btn_6" onmouseover="tabit(this)"><a href="/test/">test</a></li>			
		</ul>
	</div>
	</div>
</nav>
</div>
<div class="container">
<div class="row">
            <div class="col-md-6">
<ol class="breadcrumb">
  <li><a href="/">首页</a>&nbsp;>&nbsp;<a href="/test/">test</a></li>

</ol>
<div class="article">
    <h2 class="text-center">用连接池提高Servlet访问数据库的效率</h2>
    <span class="text-left">JSP天空网1111</span><span class="pull-right">2018-10-22 15:09:18 </span>
Java Servlet作为首选的服务器端数据处理技术，正在迅速取代CGI脚本。Servlet超越CGI的优势之一在于，不仅多个请求<br>可以共享公用资源，而且还可以在不同用户请求之间保留持续数据。本文介绍一种充分发挥该特色的实用技术，即数据库连<br>接池。<br><br><br>一、实现连接池的意义<br><br>动态Web站点往往用数据库存储的信息生成Web页面，每一个页面请求导致一次数据库访问。连接<br>数据库不仅要开销一定的通讯和内存资源，还必须完成用户验证、安全上下文配置这类任务，因而往往成为最为耗时的操<br>作。当然，实际的连接时间开销千变万化，但1到2秒延迟并非不常见。如果某个基于数据库的Web应用只需建立一次初始连<br>接，不同页面请求能够共享同一连接，就能获得显著的性能改善。<br>Servlet是一个Java类。Servlet引擎（它可能是Web服务软件的一部分，也可能是一个独立的附加模块）在系统启动或Servlet<br>第一次被请求时将该类装入Java虚拟机并创建它的一个实例。不同用户请求由同一Servlet实例的多个独立线程处理。那些要<br>求在不同请求之间持续有效的数据既可以用Servlet的实例变量来保存，也可以保存在独立的辅助对象中。<br>用JDBC访问数据库首先要创建与数据库之间的连接，获得一个连接对象（Connection），由连接对象提供执行SQL语句的方法。<br>本文介绍的数据库连接池包括一个管理类DBConnectionManager，负责提供与多个连接池对象（DBConnectionPool类）之间<br>的接口。每一个连接池对象管理一组JDBC连接对象，每一个连接对象可以被任意数量的Servlet共享。<br>类DBConnectionPool提供以下功能：<br><br>1) 从连接池获取（或创建）可用连接。<br>2) 把连接返回给连接池。<br>3) 在系统关闭时释放所有资源，关闭所有连接。<br><br>此外， DBConnectionPool类还能够处理无效连接（原来登记为可用的连接，由于某种原因不再可用，如超时，通讯问题）<br>，并能够限制连接池中的连接总数不超过某个预定值。<br>管理类DBConnectionManager用于管理多个连接池对象，它提供以下功能：<br><br>1) 装载和注册JDBC驱动程序。<br>2) 根据在属性文件中定义的属性创建连接池对象。<br>3) 实现连接池名字与其实例之间的映射。<br>4) 跟踪客户程序对连接池的引用，保证在最后一个客户程序结束时安全地关闭所有连接池。<br><br>本文余下部分将详细说明这两个类，最后给出一个示例演示Servlet使用连接池的一般过程。<br><br><br>二、具体实现<br><br>DBConnectionManager.java程序清单如下：<br><br>001 import java.io.*;<br>002 import java.sql.*;<br>003 import java.util.*;<br>004 import java.util.Date;<br>005<br>006 /**<br>007 * 管理类DBConnectionManager支持对一个或多个由属性文件定义的数据库连接<br>008 * 池的访问.客户程序可以调用getInstance()方法访问本类的唯一实例.<br>009 */<br>010 public class DBConnectionManager {<br>011 static private DBConnectionManager instance; // 唯一实例<br>012 static private int clients;<br>013<br>014 private Vector drivers = new Vector();<br>015 private PrintWriter log;<br>016 private Hashtable pools = new Hashtable();<br>017<br>018 /**<br>019 * 返回唯一实例.如果是第一次调用此方法,则创建实例<br>020 *<br>021 * @return DBConnectionManager 唯一实例<br>022 */<br>023 static synchronized public DBConnectionManager getInstance() {<br>024 if (instance == null) {<br>025 instance = new DBConnectionManager();<br>026 }<br>027 clients++;<br>028 return instance;<br>029 }<br>030<br>031 /**<br>032 * 建构函数私有以防止其它对象创建本类实例<br>033 */<br>034 private DBConnectionManager() {<br>035 init();<br>036 }<br>037<br>038 /**<br>039 * 将连接对象返回给由名字指定的连接池<br>040 *<br>041 * @param name 在属性文件中定义的连接池名字<br>042 * @param con 连接对象<br>043 */<br>044 public void freeConnection(String name, Connection con) {<br>045 DBConnectionPool pool = (DBConnectionPool) pools.get(name);<br>046 if (pool != null) {<br>047 pool.freeConnection(con);<br>048 }<br>049 }<br>050<br>051 /**<br>052 * 获得一个可用的(空闲的)连接.如果没有可用连接,且已有连接数小于最大连接数<br>053 * 限制,则创建并返回新连接<br>054 *<br>055 * @param name 在属性文件中定义的连接池名字<br>056 * @return Connection 可用连接或null<br>057 */<br>058 public Connection getConnection(String name) {<br>059 DBConnectionPool pool = (DBConnectionPool) pools.get(name);<br>060 if (pool != null) {<br>061 return pool.getConnection();<br>062 }<br>063 return null;<br>064 }<br>065<br>066 /**<br>067 * 获得一个可用连接.若没有可用连接,且已有连接数小于最大连接数限制,<br>068 * 则创建并返回新连接.否则,在指定的时间内等待其它线程释放连接.<br>069 *<br>070 * @param name 连接池名字<br>071 * @param time 以毫秒计的等待时间<br>072 * @return Connection 可用连接或null<br>073 */<br>074 public Connection getConnection(String name, long time) {<br>075 DBConnectionPool pool = (DBConnectionPool) pools.get(name);<br>076 if (pool != null) {<br>077 return pool.getConnection(time);<br>078 }<br>079 return null;<br>080 }<br>081<br>082 /**<br>083 * 关闭所有连接,撤销驱动程序的注册<br>084 */<br>085 public synchronized void release() {<br>086 // 等待直到最后一个客户程序调用<br>087 if (--clients != 0) {<br>088 return;<br>089 }<br>090<br>091 Enumeration allPools = pools.elements();<br>092 while (allPools.hasMoreElements()) {<br>093 DBConnectionPool pool = (DBConnectionPool) allPools.nextElement();<br>094 pool.release();<br>095 }<br>096 Enumeration allDrivers = drivers.elements();<br>097 while (allDrivers.hasMoreElements()) {<br>098 Driver driver = (Driver) allDrivers.nextElement();<br>099 try {<br>100 DriverManager.deregisterDriver(driver);<br>101 log(&quot;撤销JDBC驱动程序 &quot; + driver.getClass().getName()+&quot;的注册&quot;);<br>102 }<br>103 catch (SQLException e) {<br>104 log(e, &quot;无法撤销下列JDBC驱动程序的注册: &quot; + driver.getClass().getName());<br>105 }<br>106 }<br>107 }<br>108<br>109 /**<br>110 * 根据指定属性创建连接池实例.<br>111 *<br>112 * @param props 连接池属性<br>113 */<br>114 private void createPools(Properties props) {<br>115 Enumeration propNames = props.propertyNames();<br>116 while (propNames.hasMoreElements()) {<br>117 String name = (String) propNames.nextElement();<br>118 if (name.endsWith(&quot;.url&quot;)) {<br>119 String poolName = name.substring(0, name.lastIndexOf(&quot;.&quot;));<br>120 String url = props.getProperty(poolName + &quot;.url&quot;);<br>121 if (url == null) {<br>122 log(&quot;没有为连接池&quot; + poolName + &quot;指定URL&quot;);<br>123 continue;<br>124 }<br>125 String user = props.getProperty(poolName + &quot;.user&quot;);<br>126 String password = props.getProperty(poolName + &quot;.password&quot;);<br>127 String maxconn = props.getProperty(poolName + &quot;.maxconn&quot;, &quot;0&quot;);<br>128 int max;<br>129 try {<br>130 max = Integer.valueOf(maxconn).intValue();<br>131 }<br>132 catch (NumberFormatException e) {<br>133 log(&quot;错误的最大连接数限制: &quot; + maxconn + &quot; .连接池: &quot; + poolName);<br>134 max = 0;<br>135 }<br>136 DBConnectionPool pool =<br>137 new DBConnectionPool(poolName, url, user, password, max);<br>138 pools.put(poolName, pool);<br>139 log(&quot;成功创建连接池&quot; + poolName);<br>140 }<br>141 }<br>142 }<br>143<br>144 /**<br>145 * 读取属性完成初始化<br>146 */<br>147 private void init() {<br>148 InputStream is = getClass().getResourceAsStream(&quot;/db.properties&quot;);<br>149 Properties dbProps = new Properties();<br>150 try {<br>151 dbProps.load(is);<br>152 }<br>153 catch (Exception e) {<br>154 System.err.println(&quot;不能读取属性文件. &quot; +<br>155 &quot;请确保db.properties在CLASSPATH指定的路径中&quot;);<br>156 return;<br>157 }<br>158 String logFile = dbProps.getProperty(&quot;logfile&quot;, &quot;DBConnectionManager.log&quot;);<br>159 try {<br>160 log = new PrintWriter(new FileWriter(logFile, true), true);<br>161 }<br>162 catch (IOException e) {<br>163 System.err.println(&quot;无法打开日志文件: &quot; + logFile);<br>164 log = new PrintWriter(System.err);<br>165 }<br>166 loadDrivers(dbProps);<br>167 createPools(dbProps);<br>168 }<br>169<br>170 /**<br>171 * 装载和注册所有JDBC驱动程序<br>172 *<br>173 * @param props 属性<br>174 */<br>175 private void loadDrivers(Properties props) {<br>176 String driverClasses = props.getProperty(&quot;drivers&quot;);<br>177 StringTokenizer st = new StringTokenizer(driverClasses);<br>178 while (st.hasMoreElements()) {<br>179 String driverClassName = st.nextToken().trim();<br>180 try {<br>181 Driver driver = (Driver)<br>182 Class.forName(driverClassName).newInstance();<br>183 DriverManager.registerDriver(driver);<br>184 drivers.addElement(driver);<br>185 log(&quot;成功注册JDBC驱动程序&quot; + driverClassName);<br>186 }<br>187 catch (Exception e) {<br>188 log(&quot;无法注册JDBC驱动程序: &quot; +<br>189 driverClassName + &quot;, 错误: &quot; + e);<br>190 }<br>191 }<br>192 }<br>193<br>194 /**<br>195 * 将文本信息写入日志文件<br>196 */<br>197 private void log(String msg) {<br>198 log.println(new Date() + &quot;: &quot; + msg);<br>199 }<br>200<br>201 /**<br>202 * 将文本信息与异常写入日志文件<br>203 */<br>204 private void log(Throwable e, String msg) {<br>205 log.println(new Date() + &quot;: &quot; + msg);<br>206 e.printStackTrace(log);<br>207 }<br>208<br>209 /**<br>210 * 此内部类定义了一个连接池.它能够根据要求创建新连接,直到预定的最<br>211 * 大连接数为止.在返回连接给客户程序之前,它能够验证连接的有效性.<br>212 */<br>213 class DBConnectionPool {<br>214 private int checkedOut;<br>215 private Vector freeConnections = new Vector();<br>216 private int maxConn;<br>217 private String name;<br>218 private String password;<br>219 private String URL;<br>220 private String user;<br>221<br>222 /**<br>223 * 创建新的连接池<br>224 *<br>225 * @param name 连接池名字<br>226 * @param URL 数据库的JDBC URL<br>227 * @param user 数据库帐号,或 null<br>228 * @param password 密码,或 null<br>229 * @param maxConn 此连接池允许建立的最大连接数<br>230 */<br>231 public DBConnectionPool(String name, String URL, String user, String password,<br>232 int maxConn) {<br>233 this.name = name;<br>234 this.URL = URL;<br>235 this.user = user;<br>236 this.password = password;<br>237 this.maxConn = maxConn;<br>238 }<br>239<br>240 /**<br>241 * 将不再使用的连接返回给连接池<br>242 *<br>243 * @param con 客户程序释放的连接<br>244 */<br>245 public synchronized void freeConnection(Connection con) {<br>246 // 将指定连接加入到向量末尾<br>247 freeConnections.addElement(con);<br>248 checkedOut--;<br>249 notifyAll();<br>250 }<br>251<br>252 /**<br>253 * 从连接池获得一个可用连接.如没有空闲的连接且当前连接数小于最大连接<br>254 * 数限制,则创建新连接.如原来登记为可用的连接不再有效,则从向量删除之,<br>255 * 然后递归调用自己以尝试新的可用连接.<br>256 */<br>257 public synchronized Connection getConnection() {<br>258 Connection con = null;<br>259 if (freeConnections.size() &gt; 0) {<br>260 // 获取向量中第一个可用连接<br>261 con = (Connection) freeConnections.firstElement();<br>262 freeConnections.removeElementAt(0);<br>263 try {<br>264 if (con.isClosed()) {<br>265 log(&quot;从连接池&quot; + name+&quot;删除一个无效连接&quot;);<br>266 // 递归调用自己,尝试再次获取可用连接<br>267 con = getConnection();<br>268 }<br>269 }<br>270 catch (SQLException e) {<br>271 log(&quot;从连接池&quot; + name+&quot;删除一个无效连接&quot;);<br>272 // 递归调用自己,尝试再次获取可用连接<br>273 con = getConnection();<br>274 }<br>275 }<br>276 else if (maxConn == 0 || checkedOut &lt; maxConn) {<br>277 con = newConnection();<br>278 }<br>279 if (con != null) {<br>280 checkedOut++;<br>281 }<br>282 return con;<br>283 }<br>284<br>285 /**<br>286 * 从连接池获取可用连接.可以指定客户程序能够等待的最长时间<br>287 * 参见前一个getConnection()方法.<br>288 *<br>289 * @param timeout 以毫秒计的等待时间限制<br>290 */<br>291 public synchronized Connection getConnection(long timeout) {<br>292 long startTime = new Date().getTime();<br>293 Connection con;<br>294 while ((con = getConnection()) == null) {<br>295 try {<br>296 wait(timeout);<br>297 }<br>298 catch (InterruptedException e) {}<br>299 if ((new Date().getTime() - startTime) &gt;= timeout) {<br>300 // wait()返回的原因是超时<br>301 return null;<br>302 }<br>303 }<br>304 return con;<br>305 }<br>306<br>307 /**<br>308 * 关闭所有连接<br>309 */<br>310 public synchronized void release() {<br>311 Enumeration allConnections = freeConnections.elements();<br>312 while (allConnections.hasMoreElements()) {<br>313 Connection con = (Connection) allConnections.nextElement();<br>314 try {<br>315 con.close();<br>316 log(&quot;关闭连接池&quot; + name+&quot;中的一个连接&quot;);<br>317 }<br>318 catch (SQLException e) {<br>319 log(e, &quot;无法关闭连接池&quot; + name+&quot;中的连接&quot;);<br>320 }<br>321 }<br>322 freeConnections.removeAllElements();<br>323 }<br>324<br>325 /**<br>326 * 创建新的连接<br>327 */<br>328 private Connection newConnection() {<br>329 Connection con = null;<br>330 try {<br>331 if (user == null) {<br>332 con = DriverManager.getConnection(URL);<br>333 }<br>334 else {<br>335 con = DriverManager.getConnection(URL, user, password);<br>336 }<br>337 log(&quot;连接池&quot; + name+&quot;创建一个新的连接&quot;);<br>338 }<br>339 catch (SQLException e) {<br>340 log(e, &quot;无法创建下列URL的连接: &quot; + URL);<br>341 return null;<br>342 }<br>343 return con;<br>344 }<br>345 }<br>346 }<br><br><br><br><br>三、类DBConnectionPool说明<br><br>该类在209至345行实现，它表示指向某个数据库的连接池。数据库由JDBC URL标识。一个JDBC URL由三部分组成：协议标识<br>（总是jdbc），驱动程序标识（如 odbc、idb、oracle等），数据库标识（其格式依赖于驱动程序）。例如，jdbc:odbc:de<br>mo，即是一个指向demo数据库的JDBC URL，而且访问该数据库要使用JDBC-ODBC驱动程序。每个连接池都有一个供客户程序<br>使用的名字以及可选的用户帐号、密码、最大连接数限制。如果Web应用程序所支持的某些数据库操作可以被所有用户执行，<br>而其它一些操作应由特别许可的用户执行，则可以为两类操作分别定义连接池，两个连接池使用相同的JDBC URL，但使用不<br>同的帐号和密码。<br>类DBConnectionPool的建构函数需要上述所有数据作为其参数。如222至238行所示，这些数据被保存为它的实例变量：<br>如252至283行、285至305行所示， 客户程序可以使用DBConnectionPool类提供的两个方法获取可用连接。两者的共同之处<br>在于：如连接池中存在可用连接，则直接返回，否则创建新的连接并返回。如果没有可用连接且已有连接总数等于最大限制<br>数，第一个方法将直接返回null，而第二个方法将等待直到有可用连接为止。<br>所有的可用连接对象均登记在名为freeConnections的向量（Vector）中。如果向量中有多于一个的连接，getConnection()<br>总是选取第一个。同时，由于新的可用连接总是从尾部加入向量，从而使得数据库连接由于长时间闲置而被关闭的风险减低<br>到最小程度。<br>第一个getConnection()在返回可用连接给客户程序之前，调用了isClosed()方法验证连接仍旧有效。如果该连接被关闭或<br>触发异常，getConnection()递归地调用自己以尝试获取另外的可用连接。如果在向量freeConnections中不存在任何可用连<br>接，getConnection()方法检查是否已经指定最大连接数限制。如已经指定，则检查当前连接数是否已经到达极限。此处<br>maxConn为0表示没有限制。如果没有指定最大连接数限制或当前连接数小于该值，该方法尝试创建新的连接。如创建成功，<br>则增加已使用连接的计数并返回，否则返回空值。<br>如325至345行所示，创建新连接由newConnection()方法实现。创建过程与是否已经指定数据库帐号、密码有关。<br>JDBC的DriverManager类提供多个getConnection()方法，这些方法要用到JDBC URL与其它一些参数，如用户帐号和密码等。<br>DriverManager将使用指定的JDBC URL确定适合于目标数据库的驱动程序及建立连接。<br>在285至305行实现的第二个getConnection()方法需要一个以毫秒为单位的时间参数，该参数表示客户程序能够等待的最长<br>时间。建立连接的具体操作仍旧由第一个getConnection()方法实现。<br>该方法执行时先将startTime初始化为当前时间。在while循环中尝试获得一个连接。如果失败，则以给定的时间值为参数调<br>用wait()。wait()的返回可能是由于其它线程调用notify()或notifyAll()，也可能是由于预定时间已到。为找出wait()返<br>回的真正原因，程序用当前时间减开始时间（startTime），如差值大于预定时间则返回空值，否则再次调用getConnection()。<br>把空闲的连接登记到连接池由240至250行的freeConnection()方法实现，它的参数为返回给连接池的连接对象。该对象被加<br>入到freeConnections向量的末尾，然后减少已使用连接计数。调用notifyAll()是为了通知其它正在等待可用连接的线程。<br>许多Servlet引擎为实现安全关闭提供多种方法。数据库连接池需要知道该事件以保证所有连接能够正常关闭。DBConnectionManager<br>类负协调整个关闭过程，但关闭连接池中所有连接的任务则由DBConnectionPool类负责。在307至323行实现的release()<br>方法供DBConnectionManager调用。该方法遍历freeConnections向量并关闭所有连接，然后从向量中删除这些连接。<br><br><br>四、类DBConnectionManager 说明<br><br>该类只能创建一个实例，其它对象能够调用其静态方法（也称为类方法）获得该唯一实例的引用。如031至036行所示，<br>DBConnectionManager类的建构函数是私有的，这是为了避免其它对象创建该类的实例。<br>DBConnectionManager类的客户程序可以调用getInstance()方法获得对该类唯一实例的引用。如018至029行所示，类的唯<br>一实例在getInstance()方法第一次被调用期间创建，此后其引用就一直保存在静态变量instance中。每次调用getInstance()<br>都增加一个DBConnectionManager的客户程序计数。即，该计数代表引用DBConnectionManager唯一实例的客户程序总数，<br>它将被用于控制连接池的关闭操作。<br>该类实例的初始化工作由146至168行之间的私有方法init()完成。其中 getResourceAsStream()方法用于定位并打开外部<br>文件。外部文件的定位方法依赖于类装载器的实现。标准的本地类装载器查找操作总是开始于类文件所在路径，也能够搜<br>索CLASSPATH中声明的路径。db.properties是一个属性文件，它包含定义连接池的键-值对。可供定义的公用属性如下：<br><br>drivers 以空格分隔的JDBC驱动程序类列表<br>logfile 日志文件的绝对路径<br><br>其它的属性和特定连接池相关，其属性名字前应加上连接池名字：<br><br>&lt;poolname&gt;.url 数据库的 JDBC URL <br>&lt;poolname&gt;.maxconn 允许建立的最大连接数，0表示没有限制 <br>&lt;poolname&gt;.user 用于该连接池的数据库帐号<br>&lt;poolname&gt;.password 相应的密码<br><br>其中url属性是必需的，而其它属性则是可选的。数据库帐号和密码必须合法。用于Windows平台的db.properties文件示例<br>如下：<br><br>drivers=sun.jdbc.odbc.JdbcOdbcDriver jdbc.idbDriver<br>logfile=D:usersrcjavaDBConnectionManagerlog.txt<br><br>idb.url=jdbc:idb:c:localjavawebserver1.1dbdb.prp<br>idb.maxconn=2<br><br>access.url=jdbc:odbc:demo<br>access.user=demo<br>access.password=demopw<br><br>注意在Windows路径中的反斜杠必须输入2个，这是由于属性文件中的反斜杠同时也是一个转义字符。<br>init()方法在创建属性对象并读取db.properties文件之后，就开始检查logfile属性。如果属性文件中没有指定日志文件，<br>则默认为当前目录下的DBConnectionManager.log文件。如日志文件无法使用，则向System.err输出日志记录。<br>装载和注册所有在drivers属性中指定的JDBC驱动程序由170至192行之间的loadDrivers()方法实现。该方法先用StringTokenizer<br>将drivers属性值分割为对应于驱动程序名称的字符串，然后依次装载这些类并创建其实例，最后在 DriverManager中注册<br>该实例并把它加入到一个私有的向量drivers。向量drivers将用于关闭服务时从DriverManager取消所有JDBC 驱动程序的注册。<br>init()方法的最后一个任务是调用私有方法createPools()创建连接池对象。如109至142行所示，createPools()方法先创建<br>所有属性名字的枚举对象（即Enumeration对象，该对象可以想象为一个元素系列，逐次调用其nextElement()方法将顺序返<br>回各元素），然后在其中搜索名字以“.url”结尾的属性。对于每一个符合条件的属性，先提取其连接池名字部分，进而读<br>取所有属于该连接池的属性，最后创建连接池对象并把它保存在实例变量pools中。散列表（Hashtable类 ）pools实现连接<br>池名字到连接池对象之间的映射，此处以连接池名字为键，连接池对象为值。<br>为便于客户程序从指定连接池获得可用连接或将连接返回给连接池，类DBConnectionManager提供了方法getConnection()和<br>freeConnection()。所有这些方法都要求在参数中指定连接池名字，具体的连接获取或返回操作则调用对应的连接池对象完<br>成。它们的实现分别在051至064行、066至080行、038至049行。<br>如082至107行所示，为实现连接池的安全关闭，DBConnectionManager提供了方法release()。在上面我们已经提到，所有<br>DBConnectionManager的客户程序都应该调用静态方法getInstance()以获得该管理器的引用，此调用将增加客户程序计数。<br>客户程序在关闭时调用release()可以递减该计数。当最后一个客户程序调用release()，递减后的引用计数为0，就可以调<br>用各个连接池的release()方法关闭所有连接了。管理类release()方法最后的任务是撤销所有JDBC驱动程序的注册。<br><br><br>五、Servlet使用连接池示例<br><br>Servlet API所定义的Servlet生命周期类如：<br><br>1) 创建并初始化Servlet（init()方法）。<br>2) 响应客户程序的服务请求（service()方法）。<br>3) Servlet终止运行，释放所有资源（destroy()方法）。<br><br>本例演示连接池应用，上述关键步骤中的相关操作为：<br><br>1) 在init()，用实例变量connMgr 保存调用DBConnectionManager.getInstance()所返回的引用。<br>2) 在service()，调用getConnection()，执行数据库操作，用freeConnection()将连接返回给连接池。<br>3) 在destroy()，调用release()关闭所有连接，释放所有资源。<br><br>示例程序清单如下：<br><br>import java.io.*;<br>import java.sql.*;<br>import javax.servlet.*;<br>import javax.servlet.http.*;<br>public class TestServlet extends HttpServlet {<br>private DBConnectionManager connMgr;<br><br>public void init(ServletConfig conf) throws ServletException {<br>super.init(conf);<br>connMgr = DBConnectionManager.getInstance();<br>}<br><br>public void service(HttpServletRequest req, HttpServletResponse res) <br>throws IOException {<br><br>res.setContentType(&quot;text/html&quot;);<br>PrintWriter out = res.getWriter();<br>Connection con = connMgr.getConnection(&quot;idb&quot;);<br>if (con == null) {<br>out.println(&quot;不能获取数据库连接.&quot;);<br>return;<br>}<br>ResultSet rs = null;<br>ResultSetMetaData md = null;<br>Statement stmt = null;<br>try {<br>stmt = con.createStatement();<br>rs = stmt.executeQuery(&quot;SELECT * FROM EMPLOYEE&quot;);<br>md = rs.getMetaData();<br>out.println(&quot;&lt;H1&gt;职工数据&lt;/H1&gt;&quot;);<br>while (rs.next()) {<br>out.println(&quot;&lt;BR&gt;&quot;);<br>for (int i = 1; i &lt; md.getColumnCount(); i++) {<br>out.print(rs.getString(i) + &quot;, &quot;);<br>}<br>}<br>stmt.close();<br>rs.close();<br>}<br>catch (SQLException e) {<br>e.printStackTrace(out);<br>}<br>connMgr.freeConnection(&quot;idb&quot;, con);<br>}<br><br>public void destroy() {<br>connMgr.release();<br>super.destroy();<br>}<br>} <br><br></div>
</div>

<div class="col-md-4">        <div class="panel panel-default ">
            <div class="panel-head div-just"><h2></h2></div>
			<div class="panel-body">
<div class="list-group">

			
                          	<a href="/test/2018-10-22/180.html" class="list-group-item">松脂精油Terebinth<span class="badge">2</span></a>

                       
                          	<a href="/test/2018-10-22/181.html" class="list-group-item">桦木精油Birch<span class="badge">1</span></a>

                       
                          	<a href="/test/2018-10-22/182.html" class="list-group-item">绿薄荷精油Spearmint<span class="badge">1</span></a>

                       
                          	<a href="/test/2018-10-22/183.html" class="list-group-item">万寿菊精油Tagetes<span class="badge">0</span></a>

                       
                          	<a href="/test/2018-10-22/184.html" class="list-group-item">红柑精油Tangerine<span class="badge">0</span></a>

                       
                          	<a href="/test/2018-10-22/185.html" class="list-group-item">玉桂子精油Pimento<span class="badge">0</span></a>

                       
                          	<a href="/test/2018-10-22/186.html" class="list-group-item">愈创木精油Guaiacwood<span class="badge">0</span></a>

                       
                          	<a href="/test/2018-10-22/187.html" class="list-group-item">松树精油Pine<span class="badge">0</span></a>

                       
                          	<a href="/test/2018-10-22/188.html" class="list-group-item">桔精油（橘精油）Mandarin<span class="badge">0</span></a>

                       
                          	<a href="/test/2018-10-22/189.html" class="list-group-item">苦橙叶精油Petitgrain<span class="badge">0</span></a>

                       
</div>
			</div>
		</div>
			
</div>
</div>
</div>
</body>
</html>